'use strict';

//Встроенная функция setTimeout использует колбэк-функции. Создайте альтернативу, 
//использующую промисы.
//Функция delay(ms) должна возвращать промис, 
//который перейдёт в состояние «выполнен» через ms миллисекунд, 
//так чтобы мы могли добавить к нему .then:

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  delay(2000).then(() => alert('выполнилось через 2 секунды'));

//Можно ли "перевыполнить" промис?
Ч//то выведет код ниже?

  let promise = new Promise(function(resolve, reject) {
    resolve(1);
  
    setTimeout(() => resolve(2), 1000);
  });
  
  promise.then(alert);

  //Вывод будет: 1.
// Второй вызов resolve будет проигнорирован, 
// поскольку учитывается только первый вызов reject/resolve. 
// Все последующие вызовы – игнорируются.


// Сравнить then and catch

promise.then(f1).catch(f2);
// против 
promise.then(f1, f2);

// Разница в том, что если ошибка произойдёт в f1, 
// то она будет обработана в .catch в этом примерe 1;
// Другими словами, .then передаёт результат или ошибку следующему блоку .then/catch. 
// Так как в первом примере в цепочке далее имеется блок catch, 
// а во втором – нет, то ошибка в нём останется необработанной.